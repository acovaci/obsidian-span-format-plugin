/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SpanFormatPlugin2
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");

// src/editor.ts
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var SpanFormatPlugin = class {
  constructor(view) {
    this.decorations = this.buildDecorations(view);
  }
  update(update) {
    if (update.docChanged || update.viewportChanged) {
      this.decorations = this.buildDecorations(update.view);
    }
  }
  destroy() {
  }
  buildDecorations(view) {
    const builder = new import_state.RangeSetBuilder();
    const spanFormatRegex = /\{\{\s*(.+?)\s*\|(.*?)\}\}/g;
    for (let { from, to } of view.visibleRanges) {
      const text = view.state.doc.sliceString(from, to);
      let match;
      while ((match = spanFormatRegex.exec(text)) !== null) {
        console.log(`Tag: ${match[1]}, Value: ${match[2]}`);
        const startPos = from + match.index;
        const endPos = startPos + match[0].length;
        builder.add(
          startPos,
          endPos,
          import_view.Decoration.mark({
            class: `span-format span-format-editing span-format--${match[1]}`
          })
        );
        builder.add(
          startPos,
          startPos + 2,
          import_view.Decoration.mark({
            class: `span-format-delimiter span-format-delimiter-start`
          })
        );
        const classStartPos = startPos + 2;
        const classEndPos = classStartPos + match[1].length;
        const valueStartPos = classEndPos + 1;
        const valueEndPos = valueStartPos + match[2].length;
        builder.add(
          classStartPos,
          classEndPos,
          import_view.Decoration.mark({
            class: `span-format-class`
          })
        );
        builder.add(
          classEndPos,
          valueStartPos,
          import_view.Decoration.mark({
            class: `span-format-delimiter span-format-delimiter-class`
          })
        );
        builder.add(
          valueStartPos,
          valueEndPos,
          import_view.Decoration.mark({
            class: `span-format-value`
          })
        );
        builder.add(
          endPos - 2,
          endPos,
          import_view.Decoration.mark({
            class: `span-format-delimiter span-format-delimiter-end`
          })
        );
      }
    }
    return builder.finish();
  }
};
var pluginSpec = {
  decorations: (value) => value.decorations
};
var spanFormatPlugin = [import_view.ViewPlugin.fromClass(
  SpanFormatPlugin,
  pluginSpec
)];

// src/main.ts
var SpanFormatPlugin2 = class extends import_obsidian.Plugin {
  async onload() {
    this.registerEditorExtension(spanFormatPlugin);
    this.registerMarkdownPostProcessor((element, context) => {
      const paragraphs = element.findAll("p");
      for (let p of paragraphs) {
        const text = p.innerText.trim();
        const spanFormatRegex = /\{\{\s*(.+?)\s*\|(.*?)\}\}/g;
        let match;
        while ((match = spanFormatRegex.exec(text)) !== null) {
          console.log(`Tag: ${match[1]}, Value: ${match[2]}`);
          const startPos = match.index;
          const endPos = startPos + match[0].length;
          const spanFormatEl = p.createSpan({
            text: match[2]
          });
          spanFormatEl.addClasses(["span-format", "span-format-display", `span-format--${match[1]}`]);
          const before = text.slice(0, startPos);
          const after = text.slice(endPos);
          p.innerHTML = `${before}${spanFormatEl.outerHTML}${after}`;
        }
      }
    });
  }
  onunload() {
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsic3JjL21haW4udHMiLCAic3JjL2VkaXRvci50cyJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiaW1wb3J0IHsgUGx1Z2luIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbmltcG9ydCB7IHNwYW5Gb3JtYXRQbHVnaW4gfSBmcm9tIFwiLi9lZGl0b3JcIjtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU3BhbkZvcm1hdFBsdWdpbiBleHRlbmRzIFBsdWdpbiB7XG5cdGFzeW5jIG9ubG9hZCgpIHtcblx0XHR0aGlzLnJlZ2lzdGVyRWRpdG9yRXh0ZW5zaW9uKHNwYW5Gb3JtYXRQbHVnaW4pO1xuXG5cdFx0dGhpcy5yZWdpc3Rlck1hcmtkb3duUG9zdFByb2Nlc3NvcigoZWxlbWVudCwgY29udGV4dCkgPT4ge1xuXHRcdFx0Y29uc3QgcGFyYWdyYXBocyA9IGVsZW1lbnQuZmluZEFsbCgncCcpO1xuXG5cdFx0XHRmb3IgKGxldCBwIG9mIHBhcmFncmFwaHMpIHtcblx0XHRcdFx0Y29uc3QgdGV4dCA9IHAuaW5uZXJUZXh0LnRyaW0oKTtcblxuXHRcdFx0XHRjb25zdCBzcGFuRm9ybWF0UmVnZXggPSAvXFx7XFx7XFxzKiguKz8pXFxzKlxcfCguKj8pXFx9XFx9L2c7XG5cblx0XHRcdFx0bGV0IG1hdGNoO1xuXHRcdFx0XHR3aGlsZSAoKG1hdGNoID0gc3BhbkZvcm1hdFJlZ2V4LmV4ZWModGV4dCkpICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0Y29uc29sZS5sb2coYFRhZzogJHttYXRjaFsxXX0sIFZhbHVlOiAke21hdGNoWzJdfWApO1xuXG5cdFx0XHRcdFx0Y29uc3Qgc3RhcnRQb3MgPSBtYXRjaC5pbmRleDtcblx0XHRcdFx0XHRjb25zdCBlbmRQb3MgPSBzdGFydFBvcyArIG1hdGNoWzBdLmxlbmd0aDtcblxuXHRcdFx0XHRcdGNvbnN0IHNwYW5Gb3JtYXRFbCA9IHAuY3JlYXRlU3Bhbih7XG5cdFx0XHRcdFx0XHR0ZXh0OiBtYXRjaFsyXSxcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRzcGFuRm9ybWF0RWwuYWRkQ2xhc3NlcyhbJ3NwYW4tZm9ybWF0JywgJ3NwYW4tZm9ybWF0LWRpc3BsYXknLCBgc3Bhbi1mb3JtYXQtLSR7bWF0Y2hbMV19YF0pO1xuXG5cdFx0XHRcdFx0Ly8gUmVwbGFjZSB0aGUgbWF0Y2hlZCB0ZXh0IHdpdGggdGhlIHNwYW4gZWxlbWVudFxuXHRcdFx0XHRcdGNvbnN0IGJlZm9yZSA9IHRleHQuc2xpY2UoMCwgc3RhcnRQb3MpO1xuXHRcdFx0XHRcdGNvbnN0IGFmdGVyID0gdGV4dC5zbGljZShlbmRQb3MpO1xuXHRcdFx0XHRcdHAuaW5uZXJIVE1MID0gYCR7YmVmb3JlfSR7c3BhbkZvcm1hdEVsLm91dGVySFRNTH0ke2FmdGVyfWA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fVxuXG5cdG9udW5sb2FkKCkgeyB9XG59XG4iLCAiaW1wb3J0IHsgc3ludGF4VHJlZSB9IGZyb20gJ0Bjb2RlbWlycm9yL2xhbmd1YWdlJztcbmltcG9ydCB7IFJhbmdlU2V0QnVpbGRlciB9IGZyb20gJ0Bjb2RlbWlycm9yL3N0YXRlJztcbmltcG9ydCB7XG4gICAgVmlld1VwZGF0ZSxcbiAgICBQbHVnaW5WYWx1ZSxcbiAgICBFZGl0b3JWaWV3LFxuICAgIFZpZXdQbHVnaW4sXG4gICAgRGVjb3JhdGlvblNldCxcbiAgICBQbHVnaW5TcGVjLFxuICAgIERlY29yYXRpb24sXG59IGZyb20gJ0Bjb2RlbWlycm9yL3ZpZXcnO1xuXG5jbGFzcyBTcGFuRm9ybWF0UGx1Z2luIGltcGxlbWVudHMgUGx1Z2luVmFsdWUge1xuICAgIGRlY29yYXRpb25zOiBEZWNvcmF0aW9uU2V0O1xuXG4gICAgY29uc3RydWN0b3IodmlldzogRWRpdG9yVmlldykge1xuICAgICAgICB0aGlzLmRlY29yYXRpb25zID0gdGhpcy5idWlsZERlY29yYXRpb25zKHZpZXcpO1xuICAgIH1cblxuICAgIHVwZGF0ZSh1cGRhdGU6IFZpZXdVcGRhdGUpIHtcbiAgICAgICAgaWYgKHVwZGF0ZS5kb2NDaGFuZ2VkIHx8IHVwZGF0ZS52aWV3cG9ydENoYW5nZWQpIHtcbiAgICAgICAgICAgIHRoaXMuZGVjb3JhdGlvbnMgPSB0aGlzLmJ1aWxkRGVjb3JhdGlvbnModXBkYXRlLnZpZXcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgLy8gLi4uXG4gICAgfVxuXG4gICAgYnVpbGREZWNvcmF0aW9ucyh2aWV3OiBFZGl0b3JWaWV3KTogRGVjb3JhdGlvblNldCB7XG4gICAgICAgIGNvbnN0IGJ1aWxkZXIgPSBuZXcgUmFuZ2VTZXRCdWlsZGVyPERlY29yYXRpb24+KCk7XG4gICAgICAgIGNvbnN0IHNwYW5Gb3JtYXRSZWdleCA9IC9cXHtcXHtcXHMqKC4rPylcXHMqXFx8KC4qPylcXH1cXH0vZztcblxuICAgICAgICBmb3IgKGxldCB7IGZyb20sIHRvIH0gb2Ygdmlldy52aXNpYmxlUmFuZ2VzKSB7XG4gICAgICAgICAgICBjb25zdCB0ZXh0ID0gdmlldy5zdGF0ZS5kb2Muc2xpY2VTdHJpbmcoZnJvbSwgdG8pO1xuXG4gICAgICAgICAgICBsZXQgbWF0Y2g7XG4gICAgICAgICAgICB3aGlsZSAoKG1hdGNoID0gc3BhbkZvcm1hdFJlZ2V4LmV4ZWModGV4dCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFRhZzogJHttYXRjaFsxXX0sIFZhbHVlOiAke21hdGNoWzJdfWApO1xuXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhcnRQb3MgPSBmcm9tICsgbWF0Y2guaW5kZXg7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5kUG9zID0gc3RhcnRQb3MgKyBtYXRjaFswXS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgZGVjb3JhdGlvbiBmb3IgdGhlIGVudGlyZSBeXnRleHReXiByYW5nZVxuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkKFxuICAgICAgICAgICAgICAgICAgICBzdGFydFBvcyxcbiAgICAgICAgICAgICAgICAgICAgZW5kUG9zLFxuICAgICAgICAgICAgICAgICAgICBEZWNvcmF0aW9uLm1hcmsoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IGBzcGFuLWZvcm1hdCBzcGFuLWZvcm1hdC1lZGl0aW5nIHNwYW4tZm9ybWF0LS0ke21hdGNoWzFdfWAsXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkKFxuICAgICAgICAgICAgICAgICAgICBzdGFydFBvcyxcbiAgICAgICAgICAgICAgICAgICAgc3RhcnRQb3MgKyAyLFxuICAgICAgICAgICAgICAgICAgICBEZWNvcmF0aW9uLm1hcmsoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IGBzcGFuLWZvcm1hdC1kZWxpbWl0ZXIgc3Bhbi1mb3JtYXQtZGVsaW1pdGVyLXN0YXJ0YCxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgY29uc3QgY2xhc3NTdGFydFBvcyA9IHN0YXJ0UG9zICsgMjtcbiAgICAgICAgICAgICAgICBjb25zdCBjbGFzc0VuZFBvcyA9IGNsYXNzU3RhcnRQb3MgKyBtYXRjaFsxXS5sZW5ndGg7XG5cbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZVN0YXJ0UG9zID0gY2xhc3NFbmRQb3MgKyAxO1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlRW5kUG9zID0gdmFsdWVTdGFydFBvcyArIG1hdGNoWzJdLmxlbmd0aDtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCBkZWNvcmF0aW9uIGZvciB0aGUgY2xhc3MgbmFtZVxuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkKFxuICAgICAgICAgICAgICAgICAgICBjbGFzc1N0YXJ0UG9zLFxuICAgICAgICAgICAgICAgICAgICBjbGFzc0VuZFBvcyxcbiAgICAgICAgICAgICAgICAgICAgRGVjb3JhdGlvbi5tYXJrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBgc3Bhbi1mb3JtYXQtY2xhc3NgLFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG5cbiAgICAgICAgICAgICAgICAvLyBBZGQgZGVjb3JhdGlvbiBmb3IgdGhlIGNsYXNzIGRlbGltaXRlclxuICAgICAgICAgICAgICAgIGJ1aWxkZXIuYWRkKFxuICAgICAgICAgICAgICAgICAgICBjbGFzc0VuZFBvcyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVTdGFydFBvcyxcbiAgICAgICAgICAgICAgICAgICAgRGVjb3JhdGlvbi5tYXJrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBgc3Bhbi1mb3JtYXQtZGVsaW1pdGVyIHNwYW4tZm9ybWF0LWRlbGltaXRlci1jbGFzc2AsXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcblxuICAgICAgICAgICAgICAgIC8vIEFkZCBkZWNvcmF0aW9uIGZvciB0aGUgdmFsdWVcbiAgICAgICAgICAgICAgICBidWlsZGVyLmFkZChcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVTdGFydFBvcyxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVFbmRQb3MsXG4gICAgICAgICAgICAgICAgICAgIERlY29yYXRpb24ubWFyayh7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogYHNwYW4tZm9ybWF0LXZhbHVlYCxcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuXG4gICAgICAgICAgICAgICAgYnVpbGRlci5hZGQoXG4gICAgICAgICAgICAgICAgICAgIGVuZFBvcyAtIDIsXG4gICAgICAgICAgICAgICAgICAgIGVuZFBvcyxcbiAgICAgICAgICAgICAgICAgICAgRGVjb3JhdGlvbi5tYXJrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsYXNzOiBgc3Bhbi1mb3JtYXQtZGVsaW1pdGVyIHNwYW4tZm9ybWF0LWRlbGltaXRlci1lbmRgLFxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goKTtcbiAgICB9XG59XG5cbmNvbnN0IHBsdWdpblNwZWM6IFBsdWdpblNwZWM8U3BhbkZvcm1hdFBsdWdpbj4gPSB7XG4gICAgZGVjb3JhdGlvbnM6ICh2YWx1ZTogU3BhbkZvcm1hdFBsdWdpbikgPT4gdmFsdWUuZGVjb3JhdGlvbnMsXG59O1xuXG5leHBvcnQgY29uc3Qgc3BhbkZvcm1hdFBsdWdpbiA9IFtWaWV3UGx1Z2luLmZyb21DbGFzcyhcbiAgICBTcGFuRm9ybWF0UGx1Z2luLFxuICAgIHBsdWdpblNwZWNcbildO1xuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFBQTtBQUFBLGlCQUFBQTtBQUFBO0FBQUE7QUFBQSxzQkFBdUI7OztBQ0N2QixtQkFBZ0M7QUFDaEMsa0JBUU87QUFFUCxJQUFNLG1CQUFOLE1BQThDO0FBQUEsRUFHMUMsWUFBWSxNQUFrQjtBQUMxQixTQUFLLGNBQWMsS0FBSyxpQkFBaUIsSUFBSTtBQUFBLEVBQ2pEO0FBQUEsRUFFQSxPQUFPLFFBQW9CO0FBQ3ZCLFFBQUksT0FBTyxjQUFjLE9BQU8saUJBQWlCO0FBQzdDLFdBQUssY0FBYyxLQUFLLGlCQUFpQixPQUFPLElBQUk7QUFBQSxJQUN4RDtBQUFBLEVBQ0o7QUFBQSxFQUVBLFVBQVU7QUFBQSxFQUVWO0FBQUEsRUFFQSxpQkFBaUIsTUFBaUM7QUFDOUMsVUFBTSxVQUFVLElBQUksNkJBQTRCO0FBQ2hELFVBQU0sa0JBQWtCO0FBRXhCLGFBQVMsRUFBRSxNQUFNLEdBQUcsS0FBSyxLQUFLLGVBQWU7QUFDekMsWUFBTSxPQUFPLEtBQUssTUFBTSxJQUFJLFlBQVksTUFBTSxFQUFFO0FBRWhELFVB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
